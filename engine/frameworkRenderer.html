
<!DOCTYPE HTML>
<html lang="" >
    <head>
        <meta charset="UTF-8">
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <title>引擎架构之 FrameworkRenderer 封装 · GitBook</title>
        <meta http-equiv="X-UA-Compatible" content="IE=edge" />
        <meta name="description" content="">
        <meta name="generator" content="GitBook 3.2.3">
        
        
        
    
    <link rel="stylesheet" href="../gitbook/style.css">

    
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-highlight/website.css">
                
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-search/search.css">
                
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-fontsettings/website.css">
                
            
        

    

    
        
    
        
    
        
    
        
    
        
    
        
    

        
    
    
    <meta name="HandheldFriendly" content="true"/>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <link rel="apple-touch-icon-precomposed" sizes="152x152" href="../gitbook/images/apple-touch-icon-precomposed-152.png">
    <link rel="shortcut icon" href="../gitbook/images/favicon.ico" type="image/x-icon">

    
    <link rel="next" href="postprocessorRenderer.html" />
    
    
    <link rel="prev" href="resource.html" />
    

    </head>
    <body>
        
<div class="book">
    <div class="book-summary">
        
            
<div id="book-search-input" role="search">
    <input type="text" placeholder="Type to search" />
</div>

            
                <nav role="navigation">
                


<ul class="summary">
    
    

    

    
        
        
    
        <li class="chapter " data-level="1.1" data-path="../">
            
                <a href="../">
            
                    
                    背景介绍
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2" data-path="../graphicsAPI/">
            
                <a href="../graphicsAPI/">
            
                    
                    图形 API
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.2.1" data-path="../graphicsAPI/difference.html">
            
                <a href="../graphicsAPI/difference.html">
            
                    
                    OpenGL 与 Vulkan 的区别
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.2" data-path="../graphicsAPI/vulkanAPI.html">
            
                <a href="../graphicsAPI/vulkanAPI.html">
            
                    
                    Vulkan API 梳理
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.3" data-path="./">
            
                <a href="./">
            
                    
                    引擎架构
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.3.1" data-path="vulkanRenderer.html">
            
                <a href="vulkanRenderer.html">
            
                    
                    引擎架构之 Vulkan Renderer 封装
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.2" data-path="sceneData.html">
            
                <a href="sceneData.html">
            
                    
                    引擎架构之场景数据
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.3" data-path="application.html">
            
                <a href="application.html">
            
                    
                    引擎架构之应用封装
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.4" data-path="resource.html">
            
                <a href="resource.html">
            
                    
                    引擎架构之资源管理
            
                </a>
            

            
        </li>
    
        <li class="chapter active" data-level="1.3.5" data-path="frameworkRenderer.html">
            
                <a href="frameworkRenderer.html">
            
                    
                    引擎架构之 FrameworkRenderer 封装
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.6" data-path="postprocessorRenderer.html">
            
                <a href="postprocessorRenderer.html">
            
                    
                    引擎架构之 后处理 Renderer 封装
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.4" data-path="../RHI/">
            
                <a href="../RHI/">
            
                    
                    RHI 跨平台
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.5" data-path="../rendering/">
            
                <a href="../rendering/">
            
                    
                    渲染技术
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.5.1" data-path="../rendering/camera.html">
            
                <a href="../rendering/camera.html">
            
                    
                    摄像机基础
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.5.2" data-path="../rendering/quaternion.html">
            
                <a href="../rendering/quaternion.html">
            
                    
                    四元数
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.5.3" data-path="../rendering/FPS.html">
            
                <a href="../rendering/FPS.html">
            
                    
                    FPS
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.5.4" data-path="../rendering/grid.html">
            
                <a href="../rendering/grid.html">
            
                    
                    二维细分网格
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.6" data-path="../rayTracing/">
            
                <a href="../rayTracing/">
            
                    
                    光线追踪
            
                </a>
            

            
        </li>
    

    

    <li class="divider"></li>

    <li>
        <a href="https://www.gitbook.com" target="blank" class="gitbook-link">
            Published with GitBook
        </a>
    </li>
</ul>


                </nav>
            
        
    </div>

    <div class="book-body">
        
            <div class="body-inner">
                
                    

<div class="book-header" role="navigation">
    

    <!-- Title -->
    <h1>
        <i class="fa fa-circle-o-notch fa-spin"></i>
        <a href=".." >引擎架构之 FrameworkRenderer 封装</a>
    </h1>
</div>




                    <div class="page-wrapper" tabindex="-1" role="main">
                        <div class="page-inner">
                            
<div id="book-search-results">
    <div class="search-noresults">
    
                                <section class="normal markdown-section">
                                
                                <h1 id="&#x5F15;&#x64CE;&#x67B6;&#x6784;&#x4E4B;-frameworkrenderer-&#x5C01;&#x88C5;">&#x5F15;&#x64CE;&#x67B6;&#x6784;&#x4E4B; FrameworkRenderer &#x5C01;&#x88C5;</h1>
<p>VulkanApp&#xFF08;<a href="engine/application.md">&#x5F15;&#x64CE;&#x67B6;&#x6784;&#x4E4B;&#x5E94;&#x7528;&#x5C01;&#x88C5;</a>&#xFF09;&#x4E3B;&#x8981;&#x5C01;&#x88C5;&#x4E86;&#x5728; Vulkan &#x7ED8;&#x5236;&#x4E2D;&#xFF0C;&#x6BCF;&#x6B21;&#x7ED8;&#x5236;&#x90FD;&#x4E00;&#x5B9A;&#x4F1A;&#x4F7F;&#x7528;&#x7684;&#x90E8;&#x5206;&#xFF0C;&#x4E3B;&#x8981;&#x5305;&#x62EC; FrameBuffer&#x3001;SwapChain &#x53CA;&#x5176; Image &#x5BF9;&#x8C61;&#x3001;Device &#x548C; Graphic\Compute Queue&#x3001;Command Pool &#x548C; Command Buffer&#xFF0C;&#x4EE5;&#x53CA;&#x521B;&#x5EFA; Vulkan &#x8D44;&#x6E90;&#x7684;&#x901A;&#x7528;&#x65B9;&#x6CD5; VulkanResource&#xFF08;&#x8BE5;&#x5BF9;&#x8C61;&#x4ECB;&#x7ECD;&#x53C2;&#x89C1; <a href="engine/resource.md">&#x5F15;&#x64CE;&#x67B6;&#x6784;&#x4E4B;&#x8D44;&#x6E90;&#x7BA1;&#x7406;</a>&#xFF09;&#xFF0C;&#x5E76;&#x4E14;&#x628A; Vulkan &#x4ECE;&#x51C6;&#x5907;&#x4E0A;&#x4E0B;&#x6587;&#x8D44;&#x6E90;&#xFF0C;&#x4E00;&#x76F4;&#x5230;&#x63D0;&#x4EA4;&#x5230;&#x5448;&#x73B0;&#x961F;&#x5217;&#x7684;&#x8FC7;&#x7A0B;&#x90FD;&#x5C01;&#x88C5;&#x597D;&#x4E86;&#xFF0C;&#x751A;&#x81F3;&#x63D0;&#x4F9B;&#x597D;&#x4E86; Command &#x5F55;&#x5236;&#x7684;&#x4E0A;&#x4E0B;&#x6587;&#x73AF;&#x5883;&#xFF0C;&#x7559;&#x7ED9; Renderer &#x5904;&#x7406;&#x7684;&#x5C31;&#x5269; DescriptorSet&#x3001;Pipeline&#x3001;RenderPass &#x4EE5;&#x53CA; DrawCall &#x7684;&#x63D0;&#x4EA4;&#x3002;</p>
<p>&#x4E0B;&#x9762;&#x4ECE; Renderer &#x5F00;&#x59CB;&#xFF0C;&#x8BE6;&#x7EC6;&#x5206;&#x6790;&#x3002;</p>
<h2 id="renderer">Renderer</h2>
<pre><code>    struct Renderer
    {
        Renderer(VulkanRenderContext&amp; c)
        : processingWidth(c.vkDev.framebufferWidth)
        , processingHeight(c.vkDev.framebufferHeight)
        , ctx_(c)
        {}

        virtual void fillCommandBuffer(VkCommandBuffer cmdBuffer, size_t currentImage, VkFramebuffer fb = VK_NULL_HANDLE, VkRenderPass rp = VK_NULL_HANDLE) = 0;
        virtual void updateBuffers(size_t currentImage) {}

        inline void updateUniformBuffer(uint32_t currentImage, const uint32_t offset, const uint32_t size, const void* data) {
            uploadBufferData(ctx_.vkDev, uniforms_[currentImage].memory, offset, data, size);
        }

        void initPipeline(const std::vector&lt;const char*&gt;&amp; shaders, const PipelineInfo&amp; pInfo, uint32_t vtxConstSize = 0, uint32_t fragConstSize = 0)
        {
            pipelineLayout_ = ctx_.resources.addPipelineLayout(descriptorSetLayout_, vtxConstSize, fragConstSize);
            graphicsPipeline_ = ctx_.resources.addPipeline(renderPass_.handle, pipelineLayout_, shaders, pInfo);
        }

        PipelineInfo initRenderPass(const PipelineInfo&amp; pInfo, const std::vector&lt;VulkanTexture&gt;&amp; outputs,
            RenderPass renderPass = RenderPass(),
            RenderPass fallbackPass = RenderPass())
        {
            PipelineInfo outInfo = pInfo;
            if (!outputs.empty()) // offscreen rendering
            {
                printf(&quot;Creating framebuffer (outputs = %d). Output0: %dx%d; Output1: %dx%d\n&quot;, 
                    (int)outputs.size(), outputs[0].width, outputs[0].height,
                    (outputs.size() &gt; 1 ? outputs[1].width : 0), (outputs.size() &gt; 1 ? outputs[1].height : 0));
                fflush(stdout);

                processingWidth = outputs[0].width;
                processingHeight = outputs[0].height;

                outInfo.width = processingWidth;
                outInfo.height = processingHeight;

                renderPass_  = (renderPass.handle != VK_NULL_HANDLE) ? renderPass :
                        ((isDepthFormat(outputs[0].format) &amp;&amp; (outputs.size() == 1)) ? ctx_.resources.addDepthRenderPass(outputs) : ctx_.resources.addRenderPass(outputs, RenderPassCreateInfo(), true));
                framebuffer_ = ctx_.resources.addFramebuffer(renderPass_, outputs);
            } else
            {
                renderPass_ = (renderPass.handle != VK_NULL_HANDLE) ? renderPass : fallbackPass;
            }
            return outInfo;
        }

        void beginRenderPass(VkRenderPass rp, VkFramebuffer fb, VkCommandBuffer commandBuffer, size_t currentImage)
        {
            const VkClearValue clearValues[2] = {
                VkClearValue { .color = { 1.0f, 1.0f, 1.0f, 1.0f } },
                VkClearValue { .depthStencil = { 1.0f, 0 } }
            };

            const VkRect2D rect {
                .offset = { 0, 0 },
                .extent = { .width = processingWidth, .height = processingHeight }
            };

            ctx_.beginRenderPass(commandBuffer, rp, currentImage, rect,
                fb,
                (renderPass_.info.clearColor_ ? 1u : 0u) + (renderPass_.info.clearDepth_ ? 1u : 0u),
                renderPass_.info.clearColor_ ? &amp;clearValues[0] : (renderPass_.info.clearDepth_ ? &amp;clearValues[1] : nullptr));

            vkCmdBindPipeline(commandBuffer, VK_PIPELINE_BIND_POINT_GRAPHICS, graphicsPipeline_);
            vkCmdBindDescriptorSets(commandBuffer, VK_PIPELINE_BIND_POINT_GRAPHICS, pipelineLayout_, 0, 1, &amp;descriptorSets_[currentImage], 0, nullptr);
        }

        VkFramebuffer framebuffer_ = nullptr;
        RenderPass renderPass_;

        uint32_t processingWidth;
        uint32_t processingHeight;

        // Updating individual textures (9 is the binding in our Chapter7-Chapter9 IBL scene shaders)
        void updateTexture(uint32_t textureIndex, VulkanTexture newTexture, uint32_t bindingIndex = 9)
        {
            for (auto ds: descriptorSets_)
                updateTextureInDescriptorSetArray(ctx_.vkDev, ds, newTexture, textureIndex, bindingIndex);
        }

    protected:
        VulkanRenderContext&amp; ctx_;

        // Descriptor set (layout + pool + sets) -&gt; uses uniform buffers, textures, framebuffers
        VkDescriptorSetLayout descriptorSetLayout_ = nullptr;
        VkDescriptorPool descriptorPool_ = nullptr;
        std::vector&lt;VkDescriptorSet&gt; descriptorSets_;

        // 4. Pipeline &amp; render pass (using DescriptorSets &amp; pipeline state options)
        VkPipelineLayout pipelineLayout_ = nullptr;
        VkPipeline graphicsPipeline_ = nullptr;

        std::vector&lt;VulkanBuffer&gt; uniforms_;
    };
</code></pre><p>&#x5148;&#x6765;&#x770B;&#x5C5E;&#x6027;&#xFF0C;&#x6BD4;&#x5BF9;&#x4E00;&#x4E2A;&#x51FD;&#x6570;&#xFF0C;&#x53EF;&#x4EE5;&#x4E3B;&#x8981;&#x5206;&#x4E3A;&#x5165;&#x53C2;&#x3001;&#x51FD;&#x6570;&#x4F53;&#x3001;&#x7ED3;&#x679C;&#x4E09;&#x90E8;&#x5206;&#xFF1A;</p>
<ol>
<li>public &#x6743;&#x9650;&#x7684; framebuffer<em> &#x548C; renderPass</em>&#xFF0C;&#x901A;&#x8FC7; initRenderPass &#x8BBE;&#x7F6E;&#xFF0C;&#x901A;&#x8FC7; beginRenderPass &#x4F7F;&#x7528;&#xFF0C;&#x8FD9;&#x91CC;&#x4E4B;&#x6240;&#x4EE5;&#x662F; public &#x6743;&#x9650;&#xFF0C;&#x662F;&#x4E3A;&#x4E86;&#x5728; VulkanApp &#x4E2D;&#x8BBF;&#x95EE;&#xFF0C;&#x4E4B;&#x540E;&#x4F1A;&#x4F5C;&#x4E3A; fillCommandBuffer &#x7684;&#x53C2;&#x6570;&#x4F20;&#x56DE;&#x6765;&#xFF0C;&#x8FD9;&#x91CC;&#x7684; framebuffer<em> &#x548C; renderPass</em> &#x5C31;&#x76F8;&#x5F53;&#x4E8E;&#x7ED8;&#x5236;&#x7684;&#x7ED3;&#x679C;&#x90E8;&#x5206;&#xFF1B;</li>
<li>protected &#x6743;&#x9650;&#x7684; descriptorSetLayout<em>&#x3001;descriptorPool</em>&#x3001;descriptorSets_&#xFF0C;&#x4E3B;&#x8981;&#x5BF9;&#x5E94;&#x4E8E;&#x5165;&#x53C2;&#x90E8;&#x5206;&#xFF0C;&#x662F;&#x8F93;&#x5165;&#x6570;&#x636E;&#x7684;&#x90E8;&#x5206;&#xFF1B;</li>
<li>protected &#x6743;&#x9650;&#x7684; pipelineLayout<em> &#x548C; graphicsPipeline</em>&#xFF0C;&#x4E3B;&#x8981;&#x662F;&#x7528;&#x6765;&#x8BBE;&#x7F6E; pipeline &#x7BA1;&#x7EBF;&#x7684;&#x5404;&#x4E2A;&#x90E8;&#x5206;&#x7684;&#x53C2;&#x6570;&#xFF0C;&#x4EE5;&#x53CA;&#x7ED1;&#x5B9A;&#x5404;&#x4E2A;&#x9636;&#x6BB5;&#x7684; shader&#xFF0C;&#x76F8;&#x5F53;&#x4E8E;&#x51FD;&#x6570;&#x7684;&#x51FD;&#x6570;&#x4F53;&#xFF1B;</li>
<li><code>VulkanRenderContext&amp; ctx_</code> &#x7ED8;&#x5236;&#x4E0A;&#x4E0B;&#x6587;&#xFF0C;&#x91CC;&#x9762;&#x6709; vk&#x3001;vkDev &#x548C; vkResource&#xFF1B;</li>
<li><code>std::vector&lt;VulkanBuffer&gt; uniforms_</code> &#x4FDD;&#x5B58; uniform &#x6570;&#x636E;&#xFF1B;</li>
</ol>
<p>&#x518D;&#x770B;&#x51FD;&#x6570;&#x90E8;&#x5206;&#xFF1A;</p>
<ol>
<li>&#x865A;&#x51FD;&#x6570; <code>fillCommandBuffer</code> &#x548C; <code>updateBuffers</code>&#xFF0C;&#x7531;&#x5B50;&#x7C7B;&#x7EE7;&#x627F;&#x5B9E;&#x73B0;&#xFF1B;</li>
<li><code>updateUniformBuffer</code> &#x548C; <code>updateTexture</code>&#xFF0C;&#x7528;&#x6765;&#x66F4;&#x65B0; uniform &#x7F13;&#x5B58;&#x548C; texture &#x7EB9;&#x7406;&#x7684;&#x7ED1;&#x5B9A;&#x5173;&#x7CFB;&#xFF1B;</li>
<li><code>initPipeline</code> &#x521D;&#x59CB;&#x5316;&#x6E32;&#x67D3;&#x7BA1;&#x7EBF;&#x76F8;&#x5173;&#x5C5E;&#x6027; pipelineLayout<em>&#x3001;graphicsPipeline</em>&#xFF1B;</li>
<li><code>initRenderPass</code> &#x521D;&#x59CB;&#x5316; renderPass &#x548C; framebuffer&#xFF1B;</li>
<li><code>beginRenderPass</code> &#x547D;&#x4EE4;&#x5F00;&#x59CB;&#x540E;&#x7ED1;&#x5B9A;&#x4E86; renderPass&#x3001;pipeline &#x548C; descriptorSet&#xFF1B;</li>
</ol>
<h2 id="multirenderer">MultiRenderer</h2>
<p>MultiRenderer &#x662F; Renderer &#x6700;&#x91CD;&#x8981;&#x7684;&#x5B50;&#x7C7B;&#xFF0C;&#x8D1F;&#x8D23;&#x6839;&#x636E;&#x573A;&#x666F;&#x6570;&#x636E;&#x7ED8;&#x5236;&#x6A21;&#x578B;&#xFF0C;&#x8FD9;&#x91CC;&#x7684;&#x4E3B;&#x8981;&#x90E8;&#x5206;&#x6709;&#x4E09;&#x4E2A;&#xFF1A;</p>
<ol>
<li>&#x6839;&#x636E; VKSceneData&#xFF0C;&#x5728;&#x6784;&#x9020;&#x51FD;&#x6570;&#x4E2D;&#x521B;&#x5EFA; descriptorSet&#xFF1B;</li>
<li><code>fillCommandBuffer</code> &#x547D;&#x4EE4;&#x7ED8;&#x5236;&#x56FE;&#x50CF;&#xFF1B;</li>
<li><code>updateBuffers</code> &#x547D;&#x4EE4;&#x66F4;&#x65B0;&#x7F13;&#x5B58;&#xFF1B;
&#x4E0B;&#x9762;&#x4E00;&#x4E00;&#x5206;&#x6790;</li>
</ol>
<h3 id="&#x573A;&#x666F;&#x6570;&#x636E;-vkscenedata">&#x573A;&#x666F;&#x6570;&#x636E; VKSceneData</h3>
<pre><code>    struct VKSceneData
    {
        VKSceneData(VulkanRenderContext&amp; ctx,
            const char* meshFile,
            const char* sceneFile,
            const char* materialFile,
            VulkanTexture envMap,
            VulkanTexture irradianceMap,
            bool asyncLoad = false);

        // PBR &#x9700;&#x8981;&#x7684;&#x73AF;&#x5883;&#x8D34;&#x56FE;
        VulkanTexture envMapIrradiance_;
        VulkanTexture envMap_;
        VulkanTexture brdfLUT_;

        // storage buffer &#x4F20;&#x7ED9; shader
        VulkanBuffer material_;
        VulkanBuffer transforms_;

        // &#x7ED8;&#x5236;&#x4E0A;&#x4E0B;&#x6587;
        VulkanRenderContext&amp; ctx;

        // &#x7EB9;&#x7406;&#x8D34;&#x56FE;&#x6570;&#x7EC4;&#xFF0C;&#x7528;&#x6765;&#x7ED1;&#x5B9A; uniform
        TextureArrayAttachment allMaterialTextures;

        // buffer &#x7F13;&#x51B2;&#x6570;&#x7EC4;&#xFF0C;&#x7528;&#x6765;&#x7ED1;&#x5B9A; uniform
        BufferAttachment indexBuffer_;
        BufferAttachment vertexBuffer_;

        // Mesh &#x51E0;&#x4F55;&#x6570;&#x636E;
        MeshData meshData_;

        // &#x573A;&#x666F;&#x6570;&#x636E;
        Scene scene_;

        // &#x6750;&#x8D28;&#x6570;&#x636E;
        std::vector&lt;MaterialDescription&gt; materials_;

        // transform &#x6570;&#x7EC4;&#xFF0C;&#x4FDD;&#x5B58; global trnasform &#x4FE1;&#x606F;
        std::vector&lt;glm::mat4&gt; shapeTransforms_;

        // DrawData &#x4FE1;&#x606F;
        std::vector&lt;DrawData&gt; shapes_;

        void loadScene(const char* sceneFile);
        void loadMeshes(const char* meshFile);

        void convertGlobalToShapeTransforms();
        void recalculateAllTransforms();
        void uploadGlobalTransforms();

        void updateMaterial(int matIdx);

        /* Chapter 9, async loading */
        struct LoadedImageData
        {
            int index_ = 0;
            int w_ = 0;
            int h_ = 0;
            const uint8_t* img_ = nullptr;
        };

        // &#x52A0;&#x8F7D;&#x7EB9;&#x7406;&#x56FE;&#x7247;&#x6587;&#x4EF6;
        std::vector&lt;std::string&gt; textureFiles_;
        std::vector&lt;LoadedImageData&gt; loadedFiles_;
        std::mutex loadedFilesMutex_;

    private:
        // &#x591A;&#x7EBF;&#x7A0B;&#x76F8;&#x5173;
        tf::Taskflow taskflow_;
        tf::Executor executor_;
    };

    struct MeshData
    {
        std::vector&lt;uint32_t&gt; indexData_;
        std::vector&lt;float&gt; vertexData_;
        std::vector&lt;Mesh&gt; meshes_;
        std::vector&lt;BoundingBox&gt; boxes_;
    };

    struct Scene
    {
        // local transformations for each node and global transforms
        // + an array of &apos;dirty/changed&apos; local transforms
        std::vector&lt;mat4&gt; localTransform_;
        std::vector&lt;mat4&gt; globalTransform_;

        // list of nodes whose global transform must be recalculated
        std::vector&lt;int&gt; changedAtThisFrame_[MAX_NODE_LEVEL];

        // Hierarchy component
        std::vector&lt;Hierarchy&gt; hierarchy_;

        // Mesh component: Which node corresponds to which node
        std::unordered_map&lt;uint32_t, uint32_t&gt; meshes_;

        // Material component: Which material belongs to which node
        std::unordered_map&lt;uint32_t, uint32_t&gt; materialForNode_;

        // Node name component: Which name is assigned to the node
        std::unordered_map&lt;uint32_t, uint32_t&gt; nameForNode_;

        // List of scene node names
        std::vector&lt;std::string&gt; names_;

        // Debug list of material names
        std::vector&lt;std::string&gt; materialNames_;
    };

    struct PACKED_STRUCT MaterialDescription final
    {
        gpuvec4 emissiveColor_ = { 0.0f, 0.0f, 0.0f, 0.0f};
        gpuvec4 albedoColor_   = { 1.0f, 1.0f, 1.0f, 1.0f };
        // UV anisotropic roughness (isotropic lighting models use only the first value). ZW values are ignored
        gpuvec4 roughness_     = { 1.0f, 1.0f, 0.0f, 0.0f };
        float transparencyFactor_ = 1.0f;
        float alphaTest_          = 0.0f;
        float metallicFactor_     = 0.0f;
        uint32_t flags_ = sMaterialFlags_CastShadow | sMaterialFlags_ReceiveShadow;
        // maps
        uint64_t ambientOcclusionMap_  = INVALID_TEXTURE;
        uint64_t emissiveMap_          = INVALID_TEXTURE;
        uint64_t albedoMap_            = INVALID_TEXTURE;
        /// Occlusion (R), Roughness (G), Metallic (B) https://github.com/KhronosGroup/glTF/issues/857
        uint64_t metallicRoughnessMap_ = INVALID_TEXTURE;
        uint64_t normalMap_            = INVALID_TEXTURE;
        uint64_t opacityMap_           = INVALID_TEXTURE;
    };
</code></pre><p>VKSceneData &#x4E3B;&#x8981;&#x662F;&#x5C06;&#x573A;&#x666F;&#x6570;&#x636E;&#x52A0;&#x8F7D;&#x8FDB;&#x6765;&#xFF0C;&#x4FBF;&#x4E8E; MultiRenderer &#x6E32;&#x67D3;&#xFF0C;&#x5176;&#x4E2D;&#x4E3B;&#x8981;&#x5305;&#x62EC;&#x51E0;&#x4F55;&#x6570;&#x636E;&#x3001;&#x6750;&#x8D28;&#x6570;&#x636E;&#x3001;&#x53D8;&#x6362;&#x6570;&#x636E;&#x8FD9;&#x4E09;&#x90E8;&#x5206;&#xFF0C;&#x5177;&#x4F53;&#x5206;&#x6790;&#x53EF;&#x89C1; <a href="engine/sceneData.md">&#x5F15;&#x64CE;&#x67B6;&#x6784;&#x4E4B;&#x573A;&#x666F;&#x6570;&#x636E;</a>
&#x4E0B;&#x9762;&#x8BE6;&#x7EC6;&#x770B;&#x4E00;&#x4E0B; VKSceneData &#x7684;&#x6784;&#x9020;&#x51FD;&#x6570;&#xFF0C;&#x662F;&#x5982;&#x4F55;&#x5C06;&#x8FD9;&#x4E9B;&#x6570;&#x636E;&#x52A0;&#x8F7D;&#x8FDB;&#x6765;&#x7684;</p>
<pre><code>    VKSceneData::VKSceneData(VulkanRenderContext&amp; ctx,
        const char* meshFile,
        const char* sceneFile,
        const char* materialFile,
        VulkanTexture envMap,
        VulkanTexture irradianceMap,
        bool asyncLoad)
    : ctx(ctx)
    , envMapIrradiance_(irradianceMap)
    , envMap_(envMap)
    {
        brdfLUT_ = ctx.resources.loadKTX(&quot;data/brdfLUT.ktx&quot;);

        // 1. &#x52A0;&#x8F7D;&#x6750;&#x8D28;&#x6570;&#x636E;
        loadMaterials(materialFile, materials_, textureFiles_);

        std::vector&lt;VulkanTexture&gt; textures;
        for (const auto&amp; f: textureFiles_) {
            auto t = asyncLoad ? ctx.resources.addSolidRGBATexture() : ctx.resources.loadTexture2D(f.c_str());
            textures.push_back(t);
    #if 0
            if (t.image.image != nullptr)
                setVkImageName(ctx.vkDev, t.image.image, f.c_str());
    #endif
        }

        if (asyncLoad)
        {
            loadedFiles_.reserve(textureFiles_.size());

            taskflow_.for_each_index(0u, (uint32_t)textureFiles_.size(), 1u, [this](int idx)
                {
                    int w, h;
                    const uint8_t* img = stbi_load(this-&gt;textureFiles_[idx].c_str(), &amp;w, &amp;h, nullptr, STBI_rgb_alpha);
                    if (!img)
                        img = genDefaultCheckerboardImage(&amp;w, &amp;h);
                    std::lock_guard lock(loadedFilesMutex_);
                    loadedFiles_.emplace_back(LoadedImageData { idx, w, h, img });
                }
            );

            executor_.run(taskflow_);
        }

        allMaterialTextures = fsTextureArrayAttachment(textures);

        const uint32_t materialsSize = static_cast&lt;uint32_t&gt;(sizeof(MaterialDescription) * materials_.size());
        material_ = ctx.resources.addStorageBuffer(materialsSize);
        uploadBufferData(ctx.vkDev, material_.memory, 0, materials_.data(), materialsSize);

        // 2. &#x52A0;&#x8F7D;&#x51E0;&#x4F55;&#x6570;&#x636E;
        loadMeshes(meshFile);

        // 3. &#x52A0;&#x8F7D;&#x573A;&#x666F;&#x6570;&#x636E;
        loadScene(sceneFile);
    }
</code></pre><p>&#x4E0B;&#x9762;&#x5206;&#x522B;&#x770B;&#x4E0B;&#x6750;&#x8D28;&#x3001;&#x51E0;&#x4F55;&#x3001;&#x573A;&#x666F;&#x6570;&#x636E;&#x7684;&#x52A0;&#x8F7D;&#x6D41;&#x7A0B;&#xFF1A;</p>
<ol>
<li><p>&#x52A0;&#x8F7D;&#x6750;&#x8D28;&#x6570;&#x636E;</p>
<pre><code> // 1. &#x52A0;&#x8F7D;&#x6750;&#x8D28;&#x6570;&#x636E;
 loadMaterials(materialFile, materials_, textureFiles_);
 std::vector&lt;VulkanTexture&gt; textures;
 for (const auto&amp; f: textureFiles_) {
     auto t = asyncLoad ? ctx.resources.addSolidRGBATexture() : ctx.resources.loadTexture2D(f.c_str());
     textures.push_back(t);
 #if 0
     if (t.image.image != nullptr)
         setVkImageName(ctx.vkDev, t.image.image, f.c_str());
 #endif
 }
 if (asyncLoad)
 {
     loadedFiles_.reserve(textureFiles_.size());
     taskflow_.for_each_index(0u, (uint32_t)textureFiles_.size(), 1u, [this](int idx)
         {
             int w, h;
             const uint8_t* img = stbi_load(this-&gt;textureFiles_[idx].c_str(), &amp;w, &amp;h, nullptr, STBI_rgb_alpha);
             if (!img)
                 img = genDefaultCheckerboardImage(&amp;w, &amp;h);
             std::lock_guard lock(loadedFilesMutex_);
             loadedFiles_.emplace_back(LoadedImageData { idx, w, h, img });
         }
     );
     executor_.run(taskflow_);
 }
 allMaterialTextures = fsTextureArrayAttachment(textures);
 const uint32_t materialsSize = static_cast&lt;uint32_t&gt;(sizeof(MaterialDescription) * materials_.size());
 material_ = ctx.resources.addStorageBuffer(materialsSize);
 uploadBufferData(ctx.vkDev, material_.memory, 0, materials_.data(), materialsSize);
</code></pre><p> &#x5176;&#x4E2D;&#xFF0C;<code>loadMaterials(materialFile, materials_, textureFiles_);</code> &#x52A0;&#x8F7D; MaterialDescription &#x548C; &#x7EB9;&#x7406;&#x6587;&#x4EF6;&#x8DEF;&#x5F84;&#xFF0C;&#x4EE3;&#x7801;&#x5982;&#x4E0B;&#xFF1A;</p>
<pre><code> void loadMaterials(const char* fileName, std::vector&lt;MaterialDescription&gt;&amp; materials, std::vector&lt;std::string&gt;&amp; files)
 {
     FILE* f = fopen(fileName, &quot;rb&quot;);
     if (!f) {
         printf(&quot;Cannot load file %s\nPlease run SceneConverter tool from Chapter7\n&quot;, fileName);
         exit(255);
     }

     uint32_t sz;
     fread(&amp;sz, 1, sizeof(uint32_t), f);
     materials.resize(sz);
     fread(materials.data(), sizeof(MaterialDescription), materials.size(), f);
     loadStringList(f, files);
     fclose(f);
 }
</code></pre><p> &#x52A0;&#x8F7D;&#x5B8C;&#x540E;&#xFF0C;&#x5BF9;&#x4E8E; Material &#x7684;&#x5904;&#x7406;&#x5206;&#x4E3A;&#x4E24;&#x90E8;&#x5206;&#xFF0C;&#x4E00;&#x90E8;&#x5206;&#x662F;&#x52A0;&#x8F7D;&#x7EB9;&#x7406;&#x56FE;&#x7247;&#x6570;&#x636E;&#xFF0C;&#x4E00;&#x90E8;&#x5206;&#x662F;&#x5C06; MaterialDescription &#x7684;&#x6570;&#x636E;&#x4E0A;&#x4F20;&#x5230; storage buffer &#x4E2D;&#xFF1A;</p>
<pre><code> std::vector&lt;VulkanTexture&gt; textures;
 for (const auto&amp; f: textureFiles_) {
     auto t = asyncLoad ? ctx.resources.addSolidRGBATexture() : ctx.resources.loadTexture2D(f.c_str());
     textures.push_back(t);
 #if 0
     if (t.image.image != nullptr)
         setVkImageName(ctx.vkDev, t.image.image, f.c_str());
 #endif
 }

 if (asyncLoad)
 {
     loadedFiles_.reserve(textureFiles_.size());

     taskflow_.for_each_index(0u, (uint32_t)textureFiles_.size(), 1u, [this](int idx)
         {
             int w, h;
             const uint8_t* img = stbi_load(this-&gt;textureFiles_[idx].c_str(), &amp;w, &amp;h, nullptr, STBI_rgb_alpha);
             if (!img)
                 img = genDefaultCheckerboardImage(&amp;w, &amp;h);
             std::lock_guard lock(loadedFilesMutex_);
             loadedFiles_.emplace_back(LoadedImageData { idx, w, h, img });
         }
     );

     executor_.run(taskflow_);
 }

 allMaterialTextures = fsTextureArrayAttachment(textures);
</code></pre><p> &#x52A0;&#x8F7D;&#x7EB9;&#x7406;&#x53EF;&#x4EE5;&#x9009;&#x62E9;&#x540C;&#x6B65;&#x6216;&#x8005;&#x5F02;&#x6B65;&#x7684;&#x65B9;&#x5F0F;&#xFF0C;&#x540C;&#x6B65;&#x7684;&#x60C5;&#x51B5;&#x4E0B;&#xFF0C;&#x76F4;&#x63A5;&#x5C31;&#x5728;&#x4E3B;&#x7EBF;&#x7A0B;&#x52A0;&#x8F7D; texture&#xFF0C;&#x5F02;&#x6B65;&#x7684;&#x8BDD;&#x4F1A;&#x5148;&#x6784;&#x5EFA;&#x4E00;&#x4E2A;&#x5360;&#x4F4D;&#x7684; texture&#xFF0C;&#x7136;&#x540E;&#x5F02;&#x6B65;&#x52A0;&#x8F7D;&#x6570;&#x636E;&#xFF0C;&#x4E4B;&#x540E;&#x518D;&#x66F4;&#x65B0; texture&#xFF0C;&#x4EE3;&#x7801;&#x5982;&#x4E0B;&#xFF1A;    </p>
<pre><code> bool MultiRenderer::checkLoadedTextures()
 {
     VKSceneData::LoadedImageData data;

     {
         std::lock_guard lock(sceneData_.loadedFilesMutex_);

         if (sceneData_.loadedFiles_.empty())
             return false;

         data = sceneData_.loadedFiles_.back();

         sceneData_.loadedFiles_.pop_back();
     }

     this-&gt;updateTexture(data.index_, ctx_.resources.addRGBATexture(data.w_, data.h_, const_cast&lt;uint8_t*&gt;(data.img_)));

     stbi_image_free((void*)data.img_);

     return true;
 }
</code></pre><p> &#x9664;&#x4E86;&#x7EB9;&#x7406;&#x5916;&#xFF0C;&#x53E6;&#x4E00;&#x90E8;&#x5206;&#x9700;&#x8981;&#x5904;&#x7406;&#x7684;&#x662F;&#x6750;&#x8D28;&#x7684;&#x63CF;&#x8FF0;&#x4FE1;&#x606F;&#xFF1A;</p>
<pre><code> allMaterialTextures = fsTextureArrayAttachment(textures);

 const uint32_t materialsSize = static_cast&lt;uint32_t&gt;(sizeof(MaterialDescription) * materials_.size());
 material_ = ctx.resources.addStorageBuffer(materialsSize);
 uploadBufferData(ctx.vkDev, material_.memory, 0, materials_.data(), materialsSize);
</code></pre><p> &#x5176;&#x4E2D;&#xFF0C;&#x5173;&#x4E8E; <code>fsTextureArrayAttachment(textures)</code>&#xFF0C;&#x662F;&#x5C06; texture &#x5305;&#x88C5;&#x6210;&#x7EDF;&#x4E00;&#x7684; DescriptorSetAttachment &#x7684;&#x5F62;&#x5F0F;&#xFF0C;&#x5177;&#x4F53;&#x53C2;&#x89C1; <a href="engine/resource.md">&#x5F15;&#x64CE;&#x67B6;&#x6784;&#x4E4B;&#x8D44;&#x6E90;&#x7BA1;&#x7406;</a>&#xFF1B;</p>
</li>
<li><p>&#x52A0;&#x8F7D;&#x51E0;&#x4F55;&#x6570;&#x636E;</p>
<pre><code> void VKSceneData::loadMeshes(const char* meshFile)
 {
     // 1. &#x52A0;&#x8F7D; Mesh &#x6587;&#x4EF6;&#x4FE1;&#x606F;&#x5230; meshData_
     MeshFileHeader header = loadMeshData(meshFile, meshData_);

     // 2. &#x83B7;&#x53D6;&#x7D22;&#x5F15;&#x3001;&#x9876;&#x70B9;&#x7F13;&#x5B58;&#x7684;&#x5927;&#x5C0F;&#xFF0C;&#x5E76;&#x505A;&#x5BF9;&#x9F50;&#x5904;&#x7406;
     const uint32_t indexBufferSize = header.indexDataSize;
     uint32_t vertexBufferSize = header.vertexDataSize;

     const uint32_t offsetAlignment = getVulkanBufferAlignment(ctx.vkDev);
     if ((vertexBufferSize &amp; (offsetAlignment - 1)) != 0)
     {
         const size_t numFloats = (offsetAlignment - (vertexBufferSize &amp; (offsetAlignment - 1))) / sizeof(float);
         for (size_t i = 0; i != numFloats; i++)
             meshData_.vertexData_.push_back(0);
         vertexBufferSize = (vertexBufferSize + offsetAlignment) &amp; ~(offsetAlignment - 1);
     }

     // 3. &#x4E0A;&#x4F20;&#x5230; storage buffer
     VulkanBuffer storage = ctx.resources.addStorageBuffer(vertexBufferSize + indexBufferSize);
     uploadBufferData(ctx.vkDev, storage.memory, 0, meshData_.vertexData_.data(), vertexBufferSize);
     uploadBufferData(ctx.vkDev, storage.memory, vertexBufferSize, meshData_.indexData_.data(), indexBufferSize);

     vertexBuffer_ = BufferAttachment { .dInfo = { .type = VK_DESCRIPTOR_TYPE_STORAGE_BUFFER, .shaderStageFlags = VK_SHADER_STAGE_VERTEX_BIT }, .buffer = storage, .offset = 0, .size = vertexBufferSize };
     indexBuffer_  = BufferAttachment { .dInfo = { .type = VK_DESCRIPTOR_TYPE_STORAGE_BUFFER, .shaderStageFlags = VK_SHADER_STAGE_VERTEX_BIT }, .buffer = storage, .offset = vertexBufferSize, .size = indexBufferSize };
 }
</code></pre><p> &#x8FD9;&#x91CC;&#x4E3B;&#x8981;&#x662F;&#x5C06; index &#x548C; vertex &#x7F13;&#x51B2;&#x4E0A;&#x4F20;&#x4E0A;&#x53BB;&#xFF0C;Mesh &#x4FE1;&#x606F;&#xFF0C;&#x5728; loadScene &#x91CC;&#x9762;&#x7ED9; DrawData &#x7528;&#x3002;</p>
</li>
<li><p>&#x52A0;&#x8F7D;&#x573A;&#x666F;&#x6570;&#x636E;</p>
<pre><code> void VKSceneData::loadScene(const char* sceneFile)
 {
     // 1. &#x52A0;&#x8F7D;&#x573A;&#x666F;&#x6570;&#x636E;
     ::loadScene(sceneFile, scene_);

     // 2. &#x901A;&#x8FC7; DrawData &#x7EC4;&#x7EC7;&#x6BCF;&#x4E2A; IndirectDraw &#x6240;&#x9700;&#x8981;&#x7684;&#x6570;&#x636E;
     // prepare draw data buffer
     for (const auto&amp; c : scene_.meshes_) // &#x8FD9;&#x91CC;&#x7684; scene_.meshes_ &#x662F; k(nodeIndex) : v(meshIndex) &#x7684;&#x5B57;&#x5178;
     {
         auto material = scene_.materialForNode_.find(c.first); // &#x8FD9;&#x91CC;&#x7684; scene_.materialForNode_ &#x662F; k(nodeIndex) : v(materialIndex) &#x7684;&#x5B57;&#x5178;
         if (material == scene_.materialForNode_.end())
             continue;

         shapes_.push_back(
             DrawData{
                 .meshIndex = c.second,
                 .materialIndex = material-&gt;second,
                 .LOD = 0,
                 .indexOffset = meshData_.meshes_[c.second].indexOffset,
                 .vertexOffset = meshData_.meshes_[c.second].vertexOffset,
                 .transformIndex = c.first
             });
     }

     // 3. &#x8BA1;&#x7B97; global transform&#xFF0C;&#x5E76;&#x4E14;&#x6309;&#x7167; mesh &#x7684;&#x987A;&#x5E8F;&#x91CD;&#x65B0;&#x7EC4;&#x7EC7;&#x6570;&#x7EC4;&#x4E0A;&#x4F20;
     shapeTransforms_.resize(shapes_.size());
     transforms_ = ctx.resources.addStorageBuffer(shapes_.size() * sizeof(glm::mat4));

     recalculateAllTransforms();
     uploadGlobalTransforms();
 }

 void VKSceneData::recalculateAllTransforms()
 {
     // force recalculation of global transformations
     markAsChanged(scene_, 0);
     recalculateGlobalTransforms(scene_);
 }

 void VKSceneData::uploadGlobalTransforms()
 {
     convertGlobalToShapeTransforms();
      uploadBufferData(ctx.vkDev, transforms_.memory, 0, shapeTransforms_.data(), transforms_.size);
 }

 void VKSceneData::convertGlobalToShapeTransforms()
 {
     // fill the shapeTransforms_ array from globalTransforms_
     size_t i = 0;
     for (const auto&amp; c : shapes_)
         shapeTransforms_[i++] = scene_.globalTransform_[c.transformIndex];
 }
</code></pre><p> &#x573A;&#x666F;&#x6570;&#x636E;&#x4E3B;&#x8981;&#x662F;&#x5904;&#x7406; DrawData &#x548C; transform &#x4E24;&#x5927;&#x90E8;&#x5206;&#x3002;</p>
</li>
</ol>
<h3 id="&#x6784;&#x9020;&#x51FD;&#x6570;">&#x6784;&#x9020;&#x51FD;&#x6570;</h3>
<pre><code>    MultiRenderer::MultiRenderer(
        VulkanRenderContext&amp; ctx,
        VKSceneData&amp; sceneData,
        const char* vertShaderFile,
        const char* fragShaderFile,
        const std::vector&lt;VulkanTexture&gt;&amp; outputs,
        RenderPass screenRenderPass,
        const std::vector&lt;BufferAttachment&gt;&amp; auxBuffers,
        const std::vector&lt;TextureAttachment&gt;&amp; auxTextures)
    : Renderer(ctx)
    , sceneData_(sceneData)
    {
        // 1. &#x521D;&#x59CB;&#x5316; RenderPass
        const PipelineInfo pInfo = initRenderPass(PipelineInfo {}, outputs, screenRenderPass, ctx.screenRenderPass);

        // 2. &#x8BA1;&#x7B97; indirectBuffer &#x5927;&#x5C0F;
        const uint32_t indirectDataSize = (uint32_t)sceneData_.shapes_.size() * sizeof(VkDrawIndirectCommand);

        // 3. &#x6BCF;&#x4E2A; swapChain &#x4E2D;&#x7684; Image&#xFF0C;&#x5BF9;&#x5E94;&#x4E00;&#x5957;&#x7F13;&#x5B58;&#x6570;&#x636E;
        const size_t imgCount = ctx.vkDev.swapchainImages.size();
        uniforms_.resize(imgCount);
        shape_.resize(imgCount);
        indirect_.resize(imgCount);

        descriptorSets_.resize(imgCount);

        // 4. DrawData &#x5BF9;&#x5E94;&#x7F13;&#x5B58;&#x5927;&#x5C0F;
        const uint32_t shapesSize = (uint32_t)sceneData_.shapes_.size() * sizeof(DrawData);
        // 5. MVP &#x6570;&#x636E;&#x5BF9;&#x5E94;&#x7F13;&#x5B58;&#x5927;&#x5C0F;
        const uint32_t uniformBufferSize = sizeof(ubo_);

        // 6. &#x6536;&#x96C6; envMap_&#x3001;envMapIrradiance_ &#x548C; brdfLUT_&#xFF0C;&#x5982;&#x679C;&#x6709;&#x989D;&#x5916;&#x8D34;&#x56FE; auxTextures&#xFF0C;&#x4E5F;&#x53EF;&#x4EE5;&#x4F20;&#x5165;
        std::vector&lt;TextureAttachment&gt; textureAttachments;
        if (sceneData_.envMap_.width)
            textureAttachments.push_back(fsTextureAttachment(sceneData_.envMap_));
        if (sceneData_.envMapIrradiance_.width)
            textureAttachments.push_back(fsTextureAttachment(sceneData_.envMapIrradiance_));
        if (sceneData_.brdfLUT_.width)
            textureAttachments.push_back(fsTextureAttachment(sceneData_.brdfLUT_));

        for (const auto&amp; t: auxTextures)
            textureAttachments.push_back(t);

        // 7. &#x4FDD;&#x5B58; DescriptorSet &#x4E2D;&#x6240;&#x7528;&#x8D44;&#x6E90;&#x7684;&#x4FE1;&#x606F;&#xFF0C;&#x5176;&#x4E2D; buffers &#x4FDD;&#x5B58; storage buffer&#xFF0C;textures &#x4FDD;&#x5B58;&#x7EB9;&#x7406;&#x5BF9;&#x8C61;&#xFF0C;textureArrays &#x4FDD;&#x5B58;&#x7EB9;&#x7406;&#x6570;&#x7EC4;
        DescriptorSetInfo dsInfo = {
            .buffers = {
                uniformBufferAttachment(VulkanBuffer {},         0, uniformBufferSize, VK_SHADER_STAGE_VERTEX_BIT | VK_SHADER_STAGE_FRAGMENT_BIT),
                sceneData_.vertexBuffer_,
                sceneData_.indexBuffer_,
                storageBufferAttachment(VulkanBuffer {},         0, shapesSize, VK_SHADER_STAGE_VERTEX_BIT),
                storageBufferAttachment(sceneData_.material_,    0, (uint32_t)sceneData_.material_.size, VK_SHADER_STAGE_FRAGMENT_BIT),
                storageBufferAttachment(sceneData_.transforms_,  0, (uint32_t)sceneData_.transforms_.size, VK_SHADER_STAGE_VERTEX_BIT),
            },
            .textures = textureAttachments,
            .textureArrays = { sceneData_.allMaterialTextures }
        };

        // 8. &#x5982;&#x679C;&#x6709;&#x989D;&#x5916;&#x7684; buffer&#xFF0C;&#x4E5F;&#x4FDD;&#x5B58;&#x8D77;&#x6765;
        for (const auto&amp; b: auxBuffers)
            dsInfo.buffers.push_back(b);

        // 9. &#x63A5;&#x4E0B;&#x6765;&#x6839;&#x636E; dsInfo&#xFF0C;&#x521B;&#x5EFA; descriptorSets_
        descriptorSetLayout_ = ctx.resources.addDescriptorSetLayout(dsInfo);
        descriptorPool_ = ctx.resources.addDescriptorPool(dsInfo, (uint32_t)imgCount);

        for (size_t i = 0; i != imgCount; i++)
        {
            uniforms_[i] = ctx.resources.addUniformBuffer(uniformBufferSize);
            indirect_[i] = ctx.resources.addIndirectBuffer(indirectDataSize);
            updateIndirectBuffers(i);

            shape_[i] = ctx.resources.addStorageBuffer(shapesSize);
            uploadBufferData(ctx.vkDev, shape_[i].memory, 0, sceneData_.shapes_.data(), shapesSize);

            dsInfo.buffers[0].buffer = uniforms_[i];
            dsInfo.buffers[3].buffer = shape_[i];

            descriptorSets_[i] = ctx.resources.addDescriptorSet(descriptorPool_, descriptorSetLayout_);
            ctx.resources.updateDescriptorSet(descriptorSets_[i], dsInfo);
        }

        // 10. &#x521D;&#x59CB;&#x5316; pipeline
        initPipeline({ vertShaderFile, fragShaderFile }, pInfo);
    }
</code></pre><p>&#x6784;&#x9020;&#x51FD;&#x6570;&#x7684;&#x4E3B;&#x8981;&#x529F;&#x80FD;&#x5206;&#x4E3A;&#x4E09;&#x90E8;&#x5206;&#xFF1A;  </p>
<ol>
<li>&#x521D;&#x59CB;&#x5316; DescriptorSet&#xFF0C;&#x5176;&#x4E2D;&#x8BE6;&#x7EC6;&#x5206;&#x6790;&#x53C2;&#x7167; <a href="engine/resource.md">&#x5F15;&#x64CE;&#x67B6;&#x6784;&#x4E4B;&#x8D44;&#x6E90;&#x7BA1;&#x7406;</a>&#xFF1B;</li>
<li>&#x521D;&#x59CB;&#x5316; RenderPass&#xFF1B;</li>
<li>&#x521D;&#x59CB;&#x5316; Pipeline&#xFF1B;</li>
</ol>
<p>&#x5176;&#x4E2D;&#xFF0C;&#x521B;&#x5EFA; DescriptorSet &#x8FC7;&#x7A0B;&#x4E2D;&#x6D89;&#x53CA;&#x5230;&#x4E86; IndirectCmdBuffer &#x7684;&#x521B;&#x5EFA;&#xFF0C;&#x4E0B;&#x9762;&#x4F1A;&#x5206;&#x6790;&#x4E00;&#x4E0B;&#xFF1A;</p>
<pre><code>    void MultiRenderer::updateIndirectBuffers(size_t currentImage, bool* visibility)
    {
        VkDrawIndirectCommand* data = nullptr;
        vkMapMemory(ctx_.vkDev.device, indirect_[currentImage].memory, 0, sizeof(VkDrawIndirectCommand), 0, (void**)&amp;data);

        const uint32_t size = (uint32_t)sceneData_.shapes_.size();

        for (uint32_t i = 0; i != size; i++)
        {
            const uint32_t j = sceneData_.shapes_[i].meshIndex;

            const uint32_t lod = sceneData_.shapes_[i].LOD;
            data[i] = {
                .vertexCount = sceneData_.meshData_.meshes_[j].getLODIndicesCount(lod),
                .instanceCount = visibility ? (visibility[i] ? 1u : 0u) : 1u,
                .firstVertex = 0,
                .firstInstance = i
            };
        }
        vkUnmapMemory(ctx_.vkDev.device, indirect_[currentImage].memory);
    }
</code></pre><p>&#x4E3B;&#x8981;&#x662F;&#x6839;&#x636E; DrawData &#x586B;&#x5145; IndirectDrawCmd &#x6570;&#x636E;&#xFF0C;&#x5176;&#x4E2D;&#x6620;&#x5C04; Map &#x7684;&#x65F6;&#x5019;&#xFF0C;&#x6CE8;&#x610F;&#x8981;&#x4F7F;&#x7528;&#x6307;&#x9488;&#x7684;&#x6307;&#x9488;&#xFF0C;&#x8FD9;&#x6837;&#x624D;&#x80FD;&#x6B63;&#x786E;&#x586B;&#x5145;&#x6570;&#x636E;&#x3002;</p>
<h3 id="fillcommandbuffer&#x3001;updatebuffers">fillCommandBuffer&#x3001;updateBuffers</h3>
<pre><code>    void MultiRenderer::fillCommandBuffer(VkCommandBuffer commandBuffer, size_t currentImage, VkFramebuffer fb, VkRenderPass rp)
    {
        beginRenderPass((rp != VK_NULL_HANDLE) ? rp : renderPass_.handle, (fb != VK_NULL_HANDLE) ? fb : framebuffer_, commandBuffer, currentImage);

        /* For CountKHR (Vulkan 1.1) we may use indirect rendering with GPU-based object counter */
        /// vkCmdDrawIndirectCountKHR(commandBuffer, indirectBuffers_[currentImage], 0, countBuffers_[currentImage], 0, shapes.size(), sizeof(VkDrawIndirectCommand));
        /* For Vulkan 1.0 vkCmdDrawIndirect is enough */
        vkCmdDrawIndirect(commandBuffer, indirect_[currentImage].buffer, 0, (uint32_t)sceneData_.shapes_.size(), sizeof(VkDrawIndirectCommand));

        vkCmdEndRenderPass(commandBuffer);
    }

    void MultiRenderer::updateBuffers(size_t imageIndex)
    {
        updateUniformBuffer((uint32_t)imageIndex, 0, sizeof(ubo_), &amp;ubo_);
    }
</code></pre>
                                
                                </section>
                            
    </div>
    <div class="search-results">
        <div class="has-results">
            
            <h1 class="search-results-title"><span class='search-results-count'></span> results matching "<span class='search-query'></span>"</h1>
            <ul class="search-results-list"></ul>
            
        </div>
        <div class="no-results">
            
            <h1 class="search-results-title">No results matching "<span class='search-query'></span>"</h1>
            
        </div>
    </div>
</div>

                        </div>
                    </div>
                
            </div>

            
                
                <a href="resource.html" class="navigation navigation-prev " aria-label="Previous page: 引擎架构之资源管理">
                    <i class="fa fa-angle-left"></i>
                </a>
                
                
                <a href="postprocessorRenderer.html" class="navigation navigation-next " aria-label="Next page: 引擎架构之 后处理 Renderer 封装">
                    <i class="fa fa-angle-right"></i>
                </a>
                
            
        
    </div>

    <script>
        var gitbook = gitbook || [];
        gitbook.push(function() {
            gitbook.page.hasChanged({"page":{"title":"引擎架构之 FrameworkRenderer 封装","level":"1.3.5","depth":2,"next":{"title":"引擎架构之 后处理 Renderer 封装","level":"1.3.6","depth":2,"path":"engine/postprocessorRenderer.md","ref":"engine/postprocessorRenderer.md","articles":[]},"previous":{"title":"引擎架构之资源管理","level":"1.3.4","depth":2,"path":"engine/resource.md","ref":"engine/resource.md","articles":[]},"dir":"ltr"},"config":{"gitbook":"*","theme":"default","variables":{},"plugins":[],"pluginsConfig":{"highlight":{},"search":{},"lunr":{"maxIndexSize":1000000,"ignoreSpecialCharacters":false},"sharing":{"facebook":true,"twitter":true,"google":false,"weibo":false,"instapaper":false,"vk":false,"all":["facebook","google","twitter","weibo","instapaper"]},"fontsettings":{"theme":"white","family":"sans","size":2},"theme-default":{"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"},"showLevel":false}},"structure":{"langs":"LANGS.md","readme":"README.md","glossary":"GLOSSARY.md","summary":"SUMMARY.md"},"pdf":{"pageNumbers":true,"fontSize":12,"fontFamily":"Arial","paperSize":"a4","chapterMark":"pagebreak","pageBreaksBefore":"/","margin":{"right":62,"left":62,"top":56,"bottom":56}},"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"}},"file":{"path":"engine/frameworkRenderer.md","mtime":"2022-01-21T02:47:07.865Z","type":"markdown"},"gitbook":{"version":"3.2.3","time":"2022-02-23T12:30:00.796Z"},"basePath":"..","book":{"language":""}});
        });
    </script>
</div>

        
    <script src="../gitbook/gitbook.js"></script>
    <script src="../gitbook/theme.js"></script>
    
        
        <script src="../gitbook/gitbook-plugin-search/search-engine.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-search/search.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-lunr/lunr.min.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-lunr/search-lunr.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-sharing/buttons.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-fontsettings/fontsettings.js"></script>
        
    

    </body>
</html>

